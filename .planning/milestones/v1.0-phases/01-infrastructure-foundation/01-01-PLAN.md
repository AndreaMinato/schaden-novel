---
phase: 01-infrastructure-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - nuxt.config.ts
  - content.config.ts
  - tsconfig.json
  - .gitignore
  - app/app.vue
  - app/assets/css/main.css
  - app/pages/index.vue
  - app/pages/novels/[novel]/index.vue
  - app/pages/novels/[novel]/[...slug].vue
autonomous: true
requirements:
  - INFRA-01
  - INFRA-02
  - INFRA-05

must_haves:
  truths:
    - "Nuxt 4 dev server starts without errors on `pnpm dev`"
    - "queryCollection('lrg') returns 84 chapters with correct titles and paths"
    - "All content queries are wrapped in useAsyncData()"
    - "Chapter listing query uses .select() to exclude body content"
  artifacts:
    - path: "nuxt.config.ts"
      provides: "Nuxt configuration with Content v3, Nuxt UI, native SQLite connector"
      contains: "sqliteConnector.*native"
    - path: "content.config.ts"
      provides: "Per-novel collection definitions with shared schema"
      contains: "novelCollection"
    - path: "app/pages/novels/[novel]/index.vue"
      provides: "Chapter listing with metadata-only query"
      contains: "useAsyncData"
    - path: "app/pages/novels/[novel]/[...slug].vue"
      provides: "Chapter page with ContentRenderer"
      contains: "ContentRenderer"
  key_links:
    - from: "app/pages/novels/[novel]/index.vue"
      to: "queryCollection"
      via: "useAsyncData wrapper with .select() excluding body"
      pattern: "useAsyncData.*queryCollection"
    - from: "content.config.ts"
      to: "content/lrg/"
      via: "source pattern for lrg collection"
      pattern: "source.*lrg"
    - from: "app/pages/novels/[novel]/[...slug].vue"
      to: "queryCollection"
      via: "useAsyncData wrapper fetching single chapter"
      pattern: "useAsyncData.*queryCollection.*first"
---

<objective>
Scaffold a Nuxt 4 project with Nuxt UI and Nuxt Content v3, configure per-novel collections, copy test content, and create minimal pages that query content via useAsyncData.

Purpose: Establish the Nuxt 4 foundation and prove that per-novel content collections work with correct query patterns before attempting any builds or deployments.
Output: Working Nuxt 4 dev environment with queryable chapter content from the `lrg` novel (84 chapters).
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace Astro with Nuxt 4 + Nuxt UI + Nuxt Content v3</name>
  <files>
    package.json
    nuxt.config.ts
    content.config.ts
    tsconfig.json
    .gitignore
    app/app.vue
    app/assets/css/main.css
  </files>
  <action>
    **package.json** — Replace Astro dependencies with Nuxt stack:
    - Remove from dependencies: `@astrojs/mdx`, `@astrojs/rss`, `@astrojs/sitemap`, `astro`
    - Keep in devDependencies: `cheerio` (needed in Phase 4 for import scripts)
    - Add to dependencies: `nuxt` (latest 4.x), `@nuxt/content` (latest 3.x), `@nuxt/ui` (latest 4.x), `tailwindcss` (latest 4.x)
    - Update scripts section:
      ```json
      "dev": "nuxi dev",
      "build": "NODE_OPTIONS=--max-old-space-size=8192 nuxi generate",
      "preview": "npx serve .output/public",
      "deploy": "pnpm build && netlify deploy --prod --dir=.output/public --no-build"
      ```
    - Keep existing import scripts (`import:all`, `import:docs`) unchanged
    - Run `pnpm install` after updating

    **nuxt.config.ts** — Create with these exact settings:
    ```typescript
    export default defineNuxtConfig({
      modules: ['@nuxt/content', '@nuxt/ui'],
      css: ['~/assets/css/main.css'],
      content: {
        experimental: {
          sqliteConnector: 'native',  // Node 22.5+ — avoids better-sqlite3 binding issues
        },
      },
      nitro: {
        prerender: {
          crawlLinks: false,  // CRITICAL: prevents discovering 13K chapters
          routes: ['/', '/200.html', '/404.html'],
          concurrency: 4,
        },
      },
      routeRules: {
        '/': { prerender: true },
      },
      compatibilityDate: '2025-07-15',
    })
    ```

    **content.config.ts** — Create per-novel collections with shared schema helper:
    ```typescript
    import { defineContentConfig, defineCollection } from '@nuxt/content'
    import { z } from 'zod'

    const chapterSchema = z.object({
      title: z.string(),
      pubDate: z.coerce.date(),
      tags: z.array(z.string()),
    })

    function novelCollection(dir: string) {
      return defineCollection({
        type: 'page',
        source: `${dir}/**/*.md`,
        schema: chapterSchema,
      })
    }

    export default defineContentConfig({
      collections: {
        lrg: novelCollection('lrg'),
        mga: novelCollection('mga'),
        atg: novelCollection('atg'),
        overgeared: novelCollection('overgeared'),
        tmw: novelCollection('tmw'),
        htk: novelCollection('htk'),
        issth: novelCollection('issth'),
        cd: novelCollection('cd'),
        mw: novelCollection('mw'),
        rtw: novelCollection('rtw'),
      },
    })
    ```
    Define all 10 novels upfront even though only lrg has content initially. Empty collections won't cause errors.

    **tsconfig.json** — Replace with Nuxt-compatible config:
    ```json
    {
      "extends": "./.nuxt/tsconfig.json"
    }
    ```
    Nuxt auto-generates its own tsconfig in `.nuxt/`. The root file just extends it.

    **.gitignore** — Add Nuxt-specific entries (keep existing entries):
    - Add `.nuxt/` (generated types and build cache)
    - Add `.output/` (build output directory)
    - Add `.data/` (Nuxt Content database files)

    **app/app.vue** — Create minimal root component:
    ```vue
    <template>
      <UApp>
        <NuxtPage />
      </UApp>
    </template>
    ```

    **app/assets/css/main.css** — Create Tailwind + Nuxt UI imports:
    ```css
    @import "tailwindcss";
    @import "@nuxt/ui";
    ```

    The old Astro files (`src/`, `astro.config.mjs`) remain in place but are unused by Nuxt. Do NOT delete them — they serve as reference for later phases.
  </action>
  <verify>
    Run `pnpm install` — must complete without errors.
    Run `ls node_modules/nuxt node_modules/@nuxt/content node_modules/@nuxt/ui` — all three must exist.
    Verify `nuxt.config.ts`, `content.config.ts`, `app/app.vue`, `app/assets/css/main.css` all exist.
    Verify `.gitignore` contains `.nuxt/`, `.output/`, `.data/`.
  </verify>
  <done>
    Nuxt 4, Nuxt Content v3, and Nuxt UI are installed. Configuration files exist with native SQLite connector, crawlLinks disabled, and per-novel collection definitions for all 10 novels.
  </done>
</task>

<task type="auto">
  <name>Task 2: Copy test content and create pages with useAsyncData queries</name>
  <files>
    app/pages/index.vue
    app/pages/novels/[novel]/index.vue
    app/pages/novels/[novel]/[...slug].vue
  </files>
  <action>
    **Copy lrg chapters** from existing Astro content to Nuxt content directory:
    ```bash
    mkdir -p content/lrg
    cp src/content/novels/lrg/*.md content/lrg/
    ```
    Verify: `ls content/lrg/ | wc -l` should show 84 files.

    **app/pages/index.vue** — Create minimal home page:
    ```vue
    <script setup lang="ts">
    const { data: chapters } = await useAsyncData(
      'home-lrg-chapters',
      () => queryCollection('lrg')
        .select('title', 'path', 'stem')
        .order('stem', 'ASC')
        .limit(10)
        .all()
    )
    </script>

    <template>
      <div>
        <h1>Schaden Novel</h1>
        <p>Infrastructure validation — {{ chapters?.length ?? 0 }} recent lrg chapters loaded</p>
        <ul v-if="chapters">
          <li v-for="ch in chapters" :key="ch.path">
            <NuxtLink :to="ch.path">{{ ch.title }}</NuxtLink>
          </li>
        </ul>
      </div>
    </template>
    ```

    **app/pages/novels/[novel]/index.vue** — Chapter listing with metadata-only query:
    ```vue
    <script setup lang="ts">
    const route = useRoute()
    const novel = route.params.novel as string

    const { data: chapters } = await useAsyncData(
      `listing-${novel}`,
      () => queryCollection(novel)
        .select('title', 'path', 'stem')
        .order('stem', 'ASC')
        .all()
    )
    </script>

    <template>
      <div>
        <h1>{{ novel }} — {{ chapters?.length ?? 0 }} chapters</h1>
        <ul v-if="chapters">
          <li v-for="ch in chapters" :key="ch.path">
            <NuxtLink :to="ch.path">{{ ch.title }}</NuxtLink>
          </li>
        </ul>
        <p v-else>No chapters found for "{{ novel }}"</p>
      </div>
    </template>
    ```
    NOTE: `.select('title', 'path', 'stem')` deliberately excludes `body` to keep the SQLite dump small per user decision.

    **app/pages/novels/[novel]/[...slug].vue** — Chapter reader page:
    ```vue
    <script setup lang="ts">
    const route = useRoute()
    const novel = route.params.novel as string

    const { data: chapter } = await useAsyncData(
      `chapter-${novel}-${(route.params.slug as string[]).join('-')}`,
      () => queryCollection(novel)
        .path(route.path)
        .first()
    )

    if (!chapter.value) {
      throw createError({ statusCode: 404, message: 'Chapter not found' })
    }
    </script>

    <template>
      <div v-if="chapter">
        <h1>{{ chapter.title }}</h1>
        <ContentRenderer :value="chapter" />
      </div>
    </template>
    ```

    **Verify dev server works:**
    Run `pnpm dev` and confirm:
    1. Server starts without errors on http://localhost:3000
    2. Home page (/) shows "Schaden Novel" heading and lists up to 10 lrg chapters
    3. `/novels/lrg` shows all 84 chapters listed
    4. Clicking a chapter link navigates to the chapter page and renders markdown content

    **Troubleshooting:**
    - If `queryCollection(novel)` fails with type errors for dynamic collection names, use a type assertion: `queryCollection(novel as any)` and note the issue
    - If stem ordering is wrong (1, 10, 100 instead of 1, 2, 3), note the issue — ordering fix is deferred to Phase 2
    - If dev server fails with SQLite errors, verify Node version is 22.5+ with `node --version`
  </action>
  <verify>
    `ls content/lrg/ | wc -l` outputs 84.
    `pnpm dev` starts without errors.
    `curl -s http://localhost:3000/ | grep -c "Schaden Novel"` returns 1.
    `curl -s http://localhost:3000/novels/lrg | grep -c "chapters"` returns at least 1.
    `curl -s http://localhost:3000/novels/lrg/1 | grep -c "Capitolo"` returns at least 1 (chapter renders).
  </verify>
  <done>
    84 lrg chapters are copied to content/lrg/. Dev server starts. Home page, novel listing, and chapter pages all render correctly. All queryCollection() calls are wrapped in useAsyncData(). Listing queries use .select() to exclude body content.
  </done>
</task>

</tasks>

<verification>
1. `pnpm dev` starts Nuxt 4 dev server without errors
2. http://localhost:3000/ renders home page with chapter links
3. http://localhost:3000/novels/lrg lists 84 chapters
4. http://localhost:3000/novels/lrg/1 renders chapter content with markdown formatting
5. All three page files contain `useAsyncData` wrapping `queryCollection`
6. Novel listing page uses `.select()` that excludes body
7. `nuxt.config.ts` contains `sqliteConnector: 'native'` and `crawlLinks: false`
8. `content.config.ts` defines all 10 novel collections
</verification>

<success_criteria>
- Nuxt 4 dev server runs without errors
- queryCollection('lrg') returns 84 chapters with correct titles
- Chapter content renders via ContentRenderer
- All queries wrapped in useAsyncData
- Listing queries exclude body via .select()
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md`
</output>
