---
phase: 01-infrastructure-foundation
plan: 02
type: execute
wave: 2
depends_on:
  - "01-01"
files_modified:
  - nuxt.config.ts
  - package.json
autonomous: true
requirements:
  - INFRA-01
  - INFRA-03
  - INFRA-04

must_haves:
  truths:
    - "nuxi generate completes without errors and produces a static site"
    - "Static site serves locally and pages render correctly"
    - "SQLite dump size is measured and recorded"
    - "Selective prerender of ~500 chapters completes within a known time budget"
    - "Netlify deployment succeeds and site loads in browser"
  artifacts:
    - path: "package.json"
      provides: "Updated build and deploy scripts for Nuxt"
      contains: "nuxi generate"
    - path: ".output/public/index.html"
      provides: "Prerendered home page"
  key_links:
    - from: "nuxi generate"
      to: ".output/public/"
      via: "static site generation"
      pattern: ".output/public"
    - from: "netlify deploy"
      to: ".output/public/"
      via: "deploy command with --dir flag"
      pattern: "dir=.output/public"
    - from: "nuxt.config.ts routeRules"
      to: "prerendered chapter routes"
      via: "selective prerender configuration"
      pattern: "prerender.*true"
---

<objective>
Validate the static build pipeline by running nuxi generate, measuring SQLite dump size, benchmarking selective prerendering at scale with ~2,335 chapters, and deploying to Netlify.

Purpose: Prove the build pipeline works end-to-end and measure the critical unknowns (dump size, build time) before committing to full content migration.
Output: A deployed Netlify site with measured build metrics and confirmed SPA fallback strategy.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-infrastructure-foundation/01-RESEARCH.md
@.planning/phases/01-infrastructure-foundation/01-CONTEXT.md
@.planning/phases/01-infrastructure-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Run static build with lrg and measure SQLite dump size</name>
  <files>nuxt.config.ts</files>
  <action>
    **Run nuxi generate with lrg content (84 chapters):**
    ```bash
    NODE_OPTIONS=--max-old-space-size=8192 pnpm build
    ```
    This runs `nuxi generate` per the package.json script from Plan 01.

    **Verify static output exists:**
    ```bash
    ls .output/public/index.html
    ls .output/public/200.html
    ls .output/public/404.html
    ```
    All three must exist (prerendered in nuxt.config.ts routes).

    **Measure SQLite dump size:**
    ```bash
    # Find the SQLite dump file(s) in the output
    find .output/public -name "*.json" -path "*/api/_content/*" -exec ls -lh {} \;
    # Or check the full content API directory size
    du -sh .output/public/api/ 2>/dev/null || echo "No api directory"
    # Also check total output size
    du -sh .output/public/
    ```
    Record the dump size. Per phase success criteria: if it exceeds 10MB with just 84 chapters (lrg), that signals a problem before we add more novels.

    **Verify static site serves correctly:**
    ```bash
    npx serve .output/public -l 8080 &
    sleep 2
    # Test home page
    curl -s http://localhost:8080/ | grep -c "Schaden Novel"
    # Test SPA fallback (200.html should exist for client-side routing)
    ls .output/public/200.html
    # Kill the server
    kill %1
    ```

    **Record build metrics** — note these values for the SUMMARY:
    - Build duration (from command output)
    - Total output size (`du -sh .output/public/`)
    - SQLite dump size (from api/_content/ directory)
    - Number of prerendered pages

    **If dump size > 10MB with 84 chapters:** This is a red flag. The body content is likely bloating the dump. Document this finding. Possible mitigations to note (do NOT implement yet):
    1. Use `content:file:afterParse` hook to strip body from SQLite
    2. Switch listing collections to `data` type
    3. Add `.select()` constraints at build time
  </action>
  <verify>
    `ls .output/public/index.html` exists.
    `ls .output/public/200.html` exists.
    Build completed without errors (exit code 0).
    SQLite dump size is measured and recorded.
    Static site serves and home page renders.
  </verify>
  <done>
    nuxi generate completes without errors. Static output exists in .output/public/. SQLite dump size is measured. Static site serves locally and renders pages correctly.
  </done>
</task>

<task type="auto">
  <name>Task 2: Scale benchmark with mga and selective prerendering</name>
  <files>nuxt.config.ts</files>
  <action>
    **Copy mga chapters (2,335 files) to content directory:**
    ```bash
    mkdir -p content/mga
    cp src/content/novels/mga/*.md content/mga/
    ls content/mga/ | wc -l  # Expect ~2335
    ```

    **Configure selective prerendering for ~500 chapters:**
    Update `nuxt.config.ts` to prerender a subset of mga chapters. Add a `nitro.prerender.routes` hook or expand routeRules:

    Option A — Use `nitro.hooks` in nuxt.config.ts to programmatically add routes:
    ```typescript
    // In nuxt.config.ts, add to nitro config:
    hooks: {
      'prerender:routes': function (ctx) {
        // Prerender first ~500 mga chapters for benchmark
        for (let i = 1; i <= 500; i++) {
          ctx.routes.add(`/novels/mga/${i}`)
        }
        // Also prerender lrg index and all lrg chapters (84 total)
        ctx.routes.add('/novels/lrg')
        for (let i = 1; i <= 84; i++) {
          ctx.routes.add(`/novels/lrg/${i}`)
        }
      }
    }
    ```

    Option B — If the hook approach doesn't work, add explicit routes:
    ```typescript
    // In routeRules, add prerender for specific paths
    routeRules: {
      '/': { prerender: true },
      '/novels/lrg': { prerender: true },
      '/novels/lrg/**': { prerender: true },
    }
    ```
    Note: Option B with `/**` might trigger prerendering of all lrg chapters but NOT mga chapters (since crawlLinks is false, Nuxt won't discover mga routes automatically).

    **Run benchmark build:**
    ```bash
    time NODE_OPTIONS=--max-old-space-size=8192 pnpm build
    ```

    **Record benchmark metrics:**
    - Build duration with ~2,400 chapters in content (lrg 84 + mga 2,335)
    - Total output size
    - SQLite dump size with mga added
    - Number of prerendered pages
    - Memory usage (if visible in output)

    **Extrapolate for 13K chapters:**
    If build takes X minutes for ~2,400 chapters, estimate for 13K:
    - Linear extrapolation: X * (13000 / 2400)
    - Note: SQLite indexing may not be linear; document actual observations

    **Verify SPA fallback works:**
    ```bash
    npx serve .output/public -l 8080 &
    sleep 2
    # Test a prerendered chapter
    curl -s http://localhost:8080/novels/lrg/1 | grep -c "Capitolo"
    # Test a non-prerendered mga chapter (should serve 200.html for SPA fallback)
    curl -s http://localhost:8080/novels/mga/1000 | head -5
    kill %1
    ```
    Non-prerendered routes should return the SPA shell (200.html content) which handles client-side routing.

    **If build fails with OOM:** Increase memory: `NODE_OPTIONS=--max-old-space-size=16384`. If still fails, reduce prerender count and document the limit.
    **If build takes > 30 minutes:** Note the time. This is acceptable since builds are local (no timeout), but document for planning purposes.
  </action>
  <verify>
    `ls content/mga/ | wc -l` shows ~2335 files.
    Build completes without errors.
    Build time is recorded.
    Output size and dump size are recorded.
    At least 500 mga chapter routes were prerendered (check `ls .output/public/novels/mga/ | wc -l`).
  </verify>
  <done>
    mga content (2,335 chapters) is added. Selective prerender of ~500 chapters completes. Build time and dump size are measured with the combined dataset. SPA fallback strategy is confirmed for non-prerendered routes. Extrapolation for 13K chapters is documented.
  </done>
</task>

<task type="auto">
  <name>Task 3: Deploy to Netlify and verify live site</name>
  <files>package.json</files>
  <action>
    **Verify deploy script in package.json:**
    Confirm the deploy script is: `"deploy": "pnpm build && netlify deploy --prod --dir=.output/public --no-build"`

    Per user decision: builds happen locally, then upload to Netlify. The `--no-build` flag prevents Netlify from running its own build.

    **Deploy to Netlify:**
    ```bash
    netlify deploy --prod --dir=.output/public --no-build
    ```
    Run the deploy command directly (not the full `pnpm deploy` which would rebuild). We already have a valid build from Task 2.

    **If Netlify CLI is not authenticated:** This will fail with an auth error. The executor should create a dynamic checkpoint for the user to run `netlify login` or provide a token. This is expected and handled by the execute workflow.

    **If Netlify CLI is not installed:** Run `pnpm add -g netlify-cli` or `npx netlify deploy --prod --dir=.output/public --no-build`.

    **Verify deployed site:**
    After deploy, Netlify outputs the live URL. Verify:
    ```bash
    # Get the site URL from Netlify output or .netlify/state.json
    SITE_URL=$(cat .netlify/state.json 2>/dev/null | grep -o '"url":"[^"]*"' | head -1 | cut -d'"' -f4)
    # Or use the known URL
    SITE_URL="https://schaden-novel.netlify.app"

    curl -s "$SITE_URL" | grep -c "Schaden Novel"
    curl -s "$SITE_URL/novels/lrg" | head -20
    ```

    **Verify no better-sqlite3 errors:**
    The deployment should succeed without any native binding errors because we use `sqliteConnector: 'native'` with Node 22.5+. If errors appear in Netlify function logs, document them.

    **Record deployment results:**
    - Deploy success: yes/no
    - Site URL
    - Home page loads: yes/no
    - SPA navigation works: yes/no (client-side routing to non-prerendered pages)
  </action>
  <verify>
    `netlify deploy` exits with code 0.
    `curl -s https://schaden-novel.netlify.app/ | grep -c "Schaden Novel"` returns 1.
    Site loads in browser without errors.
  </verify>
  <done>
    Site is deployed to Netlify. Home page loads. Prerendered pages serve correctly. SPA fallback handles non-prerendered routes. No better-sqlite3 binding errors.
  </done>
</task>

</tasks>

<verification>
1. `nuxi generate` completes without errors for ~2,400 chapters
2. SQLite dump size is measured after lrg (84 chapters) — documented in SUMMARY
3. SQLite dump size is measured after lrg + mga (~2,400 chapters) — documented in SUMMARY
4. Selective prerender of ~500 chapters has a measured build time
5. Extrapolation for 13K chapters is documented
6. Site deploys to Netlify without better-sqlite3 errors
7. Deployed site loads and serves pages correctly
8. SPA fallback works for non-prerendered routes
9. If dump size > 10MB, an architecture concern is documented for Phase 2 decision
</verification>

<success_criteria>
- nuxi generate completes without errors
- SQLite dump size measured and documented (threshold: 10MB triggers architecture decision)
- Selective prerender benchmark with ~500 chapters completes with known time budget
- Netlify deployment succeeds
- Deployed site loads and renders correctly
- Build metrics (time, size, memory) documented in SUMMARY
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure-foundation/01-02-SUMMARY.md`

The SUMMARY must include a **Build Metrics** section with:
- Build time (lrg only, lrg + mga)
- Output size (total, SQLite dump specifically)
- Prerendered page count
- Extrapolated build time for 13K chapters
- Dump size assessment vs 10MB threshold
- Any architecture decisions triggered
</output>
