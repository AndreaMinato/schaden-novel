---
phase: 06-chapter-reader
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - app/composables/useChapterNav.ts
  - app/pages/novels/[novel]/[...slug].vue
autonomous: true
requirements: [READ-01, READ-02]

must_haves:
  truths:
    - "Opening a chapter URL renders title, body text, and prev/next navigation client-side"
    - "A loading skeleton (USkeleton bars) appears in the body area while the chapter body JSON fetches"
    - "Navigating prev/next updates the chapter content reactively without full page reload"
    - "Fetch failure shows inline error with retry button; title and nav remain visible"
    - "All existing features work: keyboard nav (Cmd+Arrow), reading progress tracking, dark mode"
  artifacts:
    - path: "app/composables/useChapterNav.ts"
      provides: "Reactive chapter navigation accepting Ref/ComputedRef params"
      contains: "toValue"
    - path: "app/pages/novels/[novel]/[...slug].vue"
      provides: "Split-fetch chapter page with skeleton loading"
      contains: "USkeleton"
  key_links:
    - from: "app/pages/novels/[novel]/[...slug].vue"
      to: "app/composables/useChapterNav.ts"
      via: "useChapterNav(novel, contentPath) with reactive refs"
      pattern: "useChapterNav\\(novel"
    - from: "app/pages/novels/[novel]/[...slug].vue"
      to: "/content/novels/{novel}/{slug}.json"
      via: "$fetch for body JSON"
      pattern: "\\$fetch.*content/novels"
    - from: "app/pages/novels/[novel]/[...slug].vue"
      to: "ContentRenderer"
      via: ":value=\"bodyData\" with fetched minimark JSON"
      pattern: "ContentRenderer.*bodyData"
---

<objective>
Refactor the chapter reader page from a fully-prerendered single-fetch model to a split-fetch SPA model: metadata from WASM SQLite (instant), body from static JSON (network fetch with skeleton). Make all route-derived values reactive for SPA chapter-to-chapter navigation.

Purpose: Phase 5 stripped chapter bodies from SQLite and extracted them to static JSON files. The chapter page must now fetch body separately and show loading feedback during the fetch.
Output: Working SPA chapter reader with skeleton loading, error handling, and reactive navigation.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-chapter-reader/06-RESEARCH.md
@.planning/phases/05-build-pipeline-spa-foundation/05-01-SUMMARY.md

# Source files to modify
@app/composables/useChapterNav.ts
@app/pages/novels/[novel]/[...slug].vue
@app/composables/useReadingProgress.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Make useChapterNav reactive for SPA navigation</name>
  <files>app/composables/useChapterNav.ts</files>
  <action>
Refactor useChapterNav to accept reactive params and re-compute when navigating between chapters in SPA mode.

Changes:
1. Change function signature from `(novel: string, currentPath: string)` to accept `Ref<string> | ComputedRef<string>` for both params. Import types from `vue`.
2. Remove `async` — do NOT await the useAsyncData call (the page will handle its own awaiting; making this non-blocking lets the composable be called without await).
3. Use `toValue(novel)` everywhere instead of bare `novel` string.
4. Add `watch: [novel]` option to useAsyncData so chapter list re-fetches when switching novels.
5. Use dynamic key function `() => \`nav-${toValue(novel)}\`` instead of static string.
6. Change `currentIndex` to use `toValue(currentPath)` instead of bare `currentPath` string.

The resulting composable:
```typescript
import type { Ref, ComputedRef } from 'vue'

export function useChapterNav(
  novel: Ref<string> | ComputedRef<string>,
  currentPath: Ref<string> | ComputedRef<string>
) {
  const { data: rawChapters } = useAsyncData(
    () => `nav-${toValue(novel)}`,
    () => queryCollection(toValue(novel) as any)
      .select('title', 'path', 'stem')
      .all(),
    { watch: [novel] }
  )

  const sortedChapters = computed(() => {
    if (!rawChapters.value) return []
    return [...rawChapters.value].sort((a, b) =>
      a.stem.localeCompare(b.stem, undefined, { numeric: true, sensitivity: 'base' })
    )
  })

  const currentIndex = computed(() =>
    sortedChapters.value.findIndex(ch => ch.path === toValue(currentPath))
  )

  const prev = computed(() =>
    currentIndex.value > 0 ? sortedChapters.value[currentIndex.value - 1] : null
  )

  const next = computed(() =>
    currentIndex.value < sortedChapters.value.length - 1
      ? sortedChapters.value[currentIndex.value + 1]
      : null
  )

  return { prev, next, chapters: sortedChapters }
}
```

Key changes from current code: `async` removed, params are Ref-typed, `toValue()` used for dereferencing, `watch` option added, dynamic key function.
  </action>
  <verify>
Run `npx nuxi typecheck` — no type errors in useChapterNav.ts. Grep for `toValue` in the file to confirm reactive pattern is applied.
  </verify>
  <done>useChapterNav accepts Ref/ComputedRef params, uses toValue() for dereferencing, has watch option for novel changes, and is no longer async.</done>
</task>

<task type="auto">
  <name>Task 2: Refactor chapter page for split-fetch SPA rendering with skeleton</name>
  <files>app/pages/novels/[novel]/[...slug].vue</files>
  <action>
Rewrite the chapter page to split metadata (SQLite) from body (JSON fetch) with loading skeleton and error handling. This is a substantial refactor of the entire `<script setup>` and template.

**Script setup changes:**

1. **Reactive route params** — Replace plain variables with computed refs:
   ```typescript
   const route = useRoute()
   const novel = computed(() => route.params.novel as string)
   const slug = computed(() => (route.params.slug as string[]).join('/'))
   const contentPath = computed(() => `/${novel.value}/${slug.value}`)
   ```

2. **Metadata query (SQLite, OK to await)** — Keep using await since WASM SQLite is fast after initial load. Use `watch` option for SPA reactivity. Select only metadata fields (title, path, stem — NOT body):
   ```typescript
   const { data: chapter, error: metaError } = await useAsyncData(
     () => `chapter-${novel.value}-${slug.value}`,
     () => queryCollection(novel.value as any)
       .select('title', 'path', 'stem')
       .path(contentPath.value)
       .first(),
     { watch: [novel, slug] }
   )
   ```

3. **Body fetch (JSON, do NOT await — show skeleton)** — Fetch body JSON from static file with silent auto-retry. Do NOT use `await` so the component renders immediately with skeleton:
   ```typescript
   const { data: bodyData, status: bodyStatus, error: bodyError, refresh: retryBody } = useAsyncData(
     () => `body-${novel.value}-${slug.value}`,
     async () => {
       const url = `/content/novels/${novel.value}/${slug.value}.json`
       try {
         return await $fetch(url)
       } catch (e) {
         // Silent auto-retry after 2s (user decision)
         await new Promise(resolve => setTimeout(resolve, 2000))
         return await $fetch(url)
       }
     },
     { watch: [novel, slug] }
   )
   ```
   CRITICAL: No `await` before this useAsyncData. The component must render immediately with metadata + skeleton.

4. **Chapter navigation** — Call the refactored composable with reactive refs (no await, no async):
   ```typescript
   const { prev, next } = useChapterNav(novel, contentPath)
   ```

5. **Reading progress** — Use `watch` on contentPath to save progress on every chapter navigation (not just initial mount). Also keep onMounted for initial load:
   ```typescript
   watch(contentPath, (path) => {
     useReadingProgress().save(novel.value, `/novels${path}`)
   })
   onMounted(() => {
     useReadingProgress().save(novel.value, `/novels${contentPath.value}`)
   })
   ```

6. **Breadcrumbs** — Update to use `.value` on reactive refs:
   ```typescript
   const breadcrumbItems = computed<BreadcrumbItem[]>(() => [
     { label: novel.value.toUpperCase(), to: `/novels/${novel.value}` },
     { label: chapter.value?.title || `Chapter ${slug.value}` },
   ])
   ```

7. **Keyboard shortcuts** — Already use `.value` on prev/next, but verify navigateTo paths use reactive refs correctly.

8. **404 handling** — Keep the 404 check for missing metadata but make it work with the metaError ref too. If both chapter and metaError indicate failure, show inline error (same pattern as body error per user decision: "Same inline error pattern for both body fetch failure and SQLite metadata failure").

**Template changes:**

Replace the single `<ContentRenderer v-if="chapter" :value="chapter" />` with a three-state body area:

```html
<article class="prose prose-lg dark:prose-invert max-w-none leading-relaxed">
  <!-- Loading skeleton (READ-02) -->
  <div v-if="bodyStatus === 'pending'" class="space-y-4 py-4">
    <USkeleton class="h-4 w-full" />
    <USkeleton class="h-4 w-full" />
    <USkeleton class="h-4 w-[90%]" />
    <USkeleton class="h-4 w-full" />
    <USkeleton class="h-4 w-[75%]" />
    <USkeleton class="h-4 w-full" />
    <USkeleton class="h-4 w-full" />
    <USkeleton class="h-4 w-[60%]" />
    <USkeleton class="h-4 w-[90%]" />
    <USkeleton class="h-4 w-[75%]" />
  </div>

  <!-- Body content (instant swap from skeleton, no animation per user decision) -->
  <ContentRenderer v-else-if="bodyData" :value="bodyData" />

  <!-- Error state with retry (user decision: inline, minimal tone) -->
  <div v-else-if="bodyError || metaError" class="py-8 text-center text-sm text-gray-500 dark:text-gray-400">
    <p>Failed to load chapter.</p>
    <UButton label="Retry" variant="outline" size="sm" class="mt-2" @click="retryBody()" />
  </div>
</article>
```

**USkeleton specs (from user decisions):**
- ~10 placeholder bars
- Varied widths: mix of 100%, 90%, 75%, 60%
- `h-4` height, `space-y-4` gap
- Inherits theme colors automatically (dark mode compatible)

**What to preserve exactly as-is:**
- Top and bottom nav button markup (UButton with prev/next)
- UBreadcrumb usage
- Keyboard shortcut defineShortcuts block (Cmd+Arrow)
- Toast notifications for first/last chapter
- Overall layout: `max-w-[65ch] mx-auto px-4 sm:px-6 py-8`

**What NOT to do:**
- Do NOT pass the SQLite `chapter` document to ContentRenderer (its body is empty stub)
- Do NOT add fade/animation transitions (user decision: instant swap)
- Do NOT restore scroll position (user decision: always start at top — existing router.options.ts handles this)
  </action>
  <verify>
1. Run `npx nuxi typecheck` — no type errors.
2. Run `npx nuxi generate` — build succeeds, body JSON files present in `.output/public/content/novels/`.
3. Grep the page file for: `USkeleton` (skeleton present), `bodyData` (split fetch), `computed(() => route.params` (reactive params), `retryBody` (error retry).
4. Verify ContentRenderer receives `bodyData` not `chapter`: grep for `:value="bodyData"`.
5. Verify no `await` before the body useAsyncData call (grep for the pattern — the metadata useAsyncData has `await`, the body one does not).
  </verify>
  <done>
Chapter page renders metadata immediately from SQLite, shows USkeleton loading bars while body JSON fetches, displays body via ContentRenderer when loaded, shows inline error with retry on failure. All route params are reactive for SPA navigation. Reading progress saves on every chapter visit. Keyboard shortcuts and dark mode work unchanged.
  </done>
</task>

</tasks>

<verification>
1. `npx nuxi typecheck` passes with no errors
2. `npx nuxi generate` completes successfully (build still under 2 min)
3. Body JSON files exist at `.output/public/content/novels/{novel}/{stem}.json`
4. Chapter page source contains: reactive computed params, split useAsyncData calls, USkeleton components, ContentRenderer with bodyData, error state with retry button
5. useChapterNav uses toValue() and accepts Ref params
6. No `await` on the body fetch useAsyncData (skeleton appears while fetching)
</verification>

<success_criteria>
- READ-01: Chapter page loads metadata from WASM SQLite (`queryCollection().select('title','path','stem')`) and body from static JSON (`$fetch('/content/novels/...')`) as separate fetches
- READ-02: USkeleton loading bars (10 bars, varied widths) display while body JSON fetches, replaced by ContentRenderer output on success
- SPA navigation: clicking prev/next updates content reactively (reactive route params + watch option)
- Error handling: inline error with retry button on fetch failure; auto-retry once after 2s
- Feature preservation: keyboard nav, reading progress, dark mode, breadcrumbs all functional
</success_criteria>

<output>
After completion, create `.planning/phases/06-chapter-reader/06-01-SUMMARY.md`
</output>
