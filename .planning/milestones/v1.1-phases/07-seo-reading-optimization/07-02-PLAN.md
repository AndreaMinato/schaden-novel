---
phase: 07-seo-reading-optimization
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/composables/useBodyCache.ts
  - app/pages/novels/[novel]/[...slug].vue
autonomous: true
requirements: [READ-03, READ-04]

must_haves:
  truths:
    - "Navigating to next chapter loads instantly when prefetch has completed"
    - "Returning to a previously visited chapter in the same session loads instantly from cache"
    - "Cache holds at most 5 entries with LRU eviction"
    - "Prefetch fires only after current chapter body finishes loading"
    - "Only next chapter is prefetched (not previous, not N+2)"
  artifacts:
    - path: "app/composables/useBodyCache.ts"
      provides: "LRU body cache with prefetch, get, set, getOrFetch methods"
      contains: "useBodyCache"
    - path: "app/pages/novels/[novel]/[...slug].vue"
      provides: "Chapter page integrated with body cache and prefetch trigger"
      contains: "useBodyCache"
  key_links:
    - from: "app/pages/novels/[novel]/[...slug].vue"
      to: "app/composables/useBodyCache.ts"
      via: "useBodyCache composable call"
      pattern: "useBodyCache\\(\\)"
    - from: "app/composables/useBodyCache.ts"
      to: "/content/novels/{novel}/{slug}.json"
      via: "$fetch for body JSON"
      pattern: "\\$fetch\\(url\\)"
    - from: "app/pages/novels/[novel]/[...slug].vue"
      to: "prefetch trigger"
      via: "watch on bodyStatus + next"
      pattern: "watch.*bodyStatus.*prefetch"
---

<objective>
Add body caching and next-chapter prefetching to the SPA chapter reader for instant navigation.

Purpose: Readers navigating between chapters should experience instant loads (no skeleton flash) for prefetched/cached content.
Output: useBodyCache composable with LRU eviction; chapter page using cache for fetches and prefetching next chapter.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-seo-reading-optimization/07-RESEARCH.md
@.planning/phases/06-chapter-reader/06-01-SUMMARY.md
@app/pages/novels/[novel]/[...slug].vue
@app/composables/useChapterNav.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useBodyCache composable with LRU eviction and prefetch</name>
  <files>app/composables/useBodyCache.ts</files>
  <action>
Create `app/composables/useBodyCache.ts` implementing:

1. **Module-level state** (singleton, survives SPA navigations, lost on refresh):
   - `const MAX_ENTRIES = 5`
   - `const cache = new Map<string, any>()` -- body data store
   - `const inflight = new Map<string, Promise<any>>()` -- in-progress fetches

2. **LRU touch function** (module-level helper):
   - Delete key then re-insert at end (Map preserves insertion order)
   - If cache.size > MAX_ENTRIES, delete first key (oldest/LRU)

3. **Exported `useBodyCache()` function** returning `{ get, set, prefetch, getOrFetch }`:

   - `get(url: string): any | null` -- Return cached value (touch to mark as recently used) or null
   - `set(url: string, data: any): void` -- Store in cache with touch
   - `prefetch(url: string): Promise<void>` -- Skip if cached or inflight. Otherwise $fetch the URL, store result in cache via touch, track in inflight Map. On error, just clean up inflight (silent failure). Per user decision: no sessionStorage, no persistence.
   - `getOrFetch(url: string): Promise<any>` -- Check cache first (return immediately). Check inflight Map (await existing promise). Otherwise fresh $fetch, store, return. This handles the navigate-before-prefetch-completes edge case.

4. **Export a `bodyUrl` helper** for cache key consistency:
   - `export function bodyUrl(novel: string, slug: string): string`
   - Returns `/content/novels/${novel}/${slug}.json`
   - Both prefetch and page fetch MUST use this function (pitfall 3 from research)

Key constraints (per user locked decisions):
- Single unified cache for both prefetched and visited bodies (NOT separate maps)
- In-memory Map only (NO sessionStorage, NO localStorage, NO persistence)
- 5-entry LRU cap
  </action>
  <verify>
- File exists at `app/composables/useBodyCache.ts`
- Exports `useBodyCache` function and `bodyUrl` helper
- Module-level Map with MAX_ENTRIES = 5
- LRU eviction logic: delete + re-insert pattern
- Inflight Map prevents duplicate fetches
- getOrFetch handles cached, inflight, and fresh-fetch cases
  </verify>
  <done>useBodyCache composable exists with LRU Map (5 entries), prefetch, getOrFetch, and bodyUrl helper</done>
</task>

<task type="auto">
  <name>Task 2: Integrate body cache and prefetch into chapter page</name>
  <files>app/pages/novels/[novel]/[...slug].vue</files>
  <action>
Modify `app/pages/novels/[novel]/[...slug].vue` to use the body cache:

1. **Import and initialize:**
   - `const { getOrFetch, prefetch } = useBodyCache()`
   - Import `bodyUrl` from `useBodyCache`

2. **Replace body fetch with cache-aware fetch:**
   - Current pattern: `useAsyncData` with `$fetch` for body JSON
   - New pattern: `useAsyncData` with `getOrFetch(bodyUrl(novel.value, slug.value))`
   - This checks cache first, awaits in-flight prefetch if exists, or does fresh fetch
   - Keep the same `watch: [novel, slug]` reactivity for SPA navigation
   - Keep `lazy: true` / non-awaited pattern so skeleton still shows on fresh fetch

3. **Add prefetch trigger:**
   - Watch for body load completion AND next chapter availability together
   - Use `watch([bodyStatus, next], ([status, nextChapter]) => { ... })` to handle timing (pitfall 4 from research)
   - Guard: only prefetch when `status === 'success'` AND `nextChapter` is truthy
   - Build next chapter URL: `bodyUrl(novel.value, nextSlug)` where nextSlug is derived from `nextChapter.path`
   - Call `prefetch(nextUrl)` (fire-and-forget, non-blocking)
   - Per user decision: prefetch NEXT only (not previous, not N+2)

4. **Derive next chapter slug correctly:**
   - `next.value.path` is content path like `/mga/123`
   - Extract slug: `next.value.path.split('/').slice(2).join('/')` (strip leading /novel/)
   - Use bodyUrl to ensure consistent cache key

5. **Do NOT change:**
   - Metadata fetch (still uses SQLite via useAsyncData)
   - Skeleton loading UI (still shows while body fetches)
   - Error handling (existing retry logic unchanged)
   - Reading progress tracking (existing watch + onMounted pattern)
  </action>
  <verify>
- Chapter page imports and uses `useBodyCache`
- Body fetch goes through `getOrFetch` (cache-aware)
- Watch on `[bodyStatus, next]` triggers prefetch of next chapter
- Prefetch only fires when both body is loaded AND next chapter is known
- bodyUrl helper used for both current fetch and prefetch (consistent cache keys)
- Skeleton loading still works for uncached chapters
- Dev server: navigate between chapters, check Network tab shows prefetch request after body loads
  </verify>
  <done>Chapter page uses body cache for all fetches; next chapter prefetched after current loads; returning to visited chapter loads from cache without network request</done>
</task>

</tasks>

<verification>
- `useBodyCache` composable exists with LRU Map, prefetch, and getOrFetch
- Chapter page fetches bodies through cache
- Navigating forward: next chapter body prefetched after current loads
- Navigating back: previously visited chapter loads from memory cache
- Cache never exceeds 5 entries
- Skeleton still shows for uncached chapters (no await blocking)
</verification>

<success_criteria>
- Next chapter navigation is instant when prefetch completed
- Previously visited chapters load from memory cache
- Cache size capped at 5 entries with LRU eviction
- No regressions in chapter rendering, navigation, or reading progress
</success_criteria>

<output>
After completion, create `.planning/phases/07-seo-reading-optimization/07-02-SUMMARY.md`
</output>
