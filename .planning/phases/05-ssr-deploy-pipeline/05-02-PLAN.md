---
phase: 05-ssr-deploy-pipeline
plan: 02
type: execute
wave: 2
depends_on:
  - "05-01"
files_modified: []
autonomous: false
requirements:
  - BUILD-04

must_haves:
  truths:
    - "nuxt build produces .output/server/ with server function entry point"
    - "Server function bundle is under 50MB zipped (Lambda limit)"
    - "Site is live on Netlify serving pages through the server function"
    - "Health endpoint at /api/health returns status ok with SQLite query result"
    - "Cold start TTFB is under 3 seconds"
  artifacts:
    - path: ".output/server/index.mjs"
      provides: "Server function entry point"
    - path: ".output/public/__nuxt_content/"
      provides: "Content SQL dumps served from CDN"
  key_links:
    - from: "netlify.toml"
      to: ".output/"
      via: "build command produces SSR output"
      pattern: "pnpm run build"
    - from: ".output/server/"
      to: "Netlify Lambda"
      via: "@netlify/nuxt packages server function"
      pattern: "functions-internal"
---

<objective>
Build the project with `nuxt build`, verify the output is a valid SSR server function (not static-only), inspect bundle sizes for Lambda limits, then deploy to Netlify and validate the live site serves pages correctly.

Purpose: Prove the SSR pipeline works end-to-end — from build to live site — and that the critical risks (bundle size, cold start TTFB, better-sqlite3 on Lambda) are resolved.
Output: Live SSR site on Netlify with validated health check.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ssr-deploy-pipeline/05-RESEARCH.md
@.planning/phases/05-ssr-deploy-pipeline/05-01-SUMMARY.md

@nuxt.config.ts
@netlify.toml
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Run nuxt build and inspect SSR output</name>
  <files></files>
  <action>
**Build:**
Run `pnpm run build` (which executes `nuxt build`). This should produce `.output/` with both `public/` (static assets) and `server/` (server function).

**Inspect output structure:**
1. Verify `.output/server/index.mjs` exists (server function entry point)
2. Check `.output/server/` total size: `du -sh .output/server/`
3. Check `.output/public/__nuxt_content/` for SQL dump files — these should be CDN-served, NOT in the server bundle
4. Check total `.output/` size breakdown: `du -sh .output/server/ .output/public/`

**Bundle size check (critical):**
The Lambda function zip limit is 50MB. Check:
- `du -sh .output/server/` — if > 40MB, the zipped bundle likely exceeds 50MB
- Look for sql_dump files inside `.output/server/` — if present, that's the blocker
- If sql_dump files are only in `.output/public/__nuxt_content/`, bundle is safe

**Build time check:**
- Build should complete in under 2 minutes (only prerendering /, /404, RSS feeds — NOT 13K chapters)
- If build takes >5 minutes, check whether the prerender:routes hook was properly removed

**If bundle size exceeds 40MB:**
Document the finding. This triggers the pivot threshold from the research:
- If sql_dump is in the server bundle → investigate @netlify/nuxt blob storage or Turso pivot
- Report exact sizes for user decision

**If build fails:**
- Check for better-sqlite3 compilation errors (native module)
- Check for missing @netlify/nuxt module resolution
- Check for content database initialization errors
  </action>
  <verify>
1. `test -f .output/server/index.mjs` succeeds
2. `du -sh .output/server/` shows reasonable size (ideally < 30MB)
3. `ls .output/public/__nuxt_content/` shows per-novel sql_dump files
4. Build completed in under 5 minutes
  </verify>
  <done>
`nuxt build` produces a server function in `.output/server/` with the content database handled appropriately (either CDN-served or within Lambda limits). Build completes quickly without prerendering 13K routes.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Deploy to Netlify and validate live SSR site</name>
  <files></files>
  <action>
Deploy the SSR build to Netlify. Attempt in order:
1. Push code to `feature/nuxt` branch — if Netlify CI is connected, it builds automatically
2. If no CI trigger, run `netlify deploy --prod --build` to deploy with Netlify's build tooling
3. Monitor build logs for errors (especially better-sqlite3 compilation on Linux)
  </action>
  <verify>
**User validates the live site:**

1. **Pages render:** Visit the site URL. Home page loads with novel listings. Click into a novel — chapter list loads. Click a chapter — content renders with full body text (not empty).

2. **Health endpoint:** Visit `{site-url}/api/health`. Should return JSON:
   `{ "status": "ok", "database": "sqlite", "connector": "better-sqlite3", "latency_ms": N, "content_count": N }`
   `content_count` should be > 0 (mga has ~2400 chapters).

3. **TTFB measurement:** Open browser DevTools, Network tab. Load a chapter page. Check TTFB in the timing breakdown. Should be under 1 second for warm requests.

4. **Cold start check (do later):** After 30+ minutes of no traffic, revisit `/api/health`. TTFB should be under 3 seconds. This confirms Lambda cold start is acceptable.

**If health endpoint returns error:**
- Check Netlify function logs for better-sqlite3 or SQLite errors
- Check if sql_dump files are accessible to the server function

**If TTFB > 3 seconds consistently:**
- This triggers the Turso pivot threshold per Phase 5 research
- Report the measured TTFB values
  </verify>
  <done>
Site is live on Netlify serving pages via SSR server function. Health endpoint returns OK with SQLite query results. Cold start TTFB is under 3 seconds.
  </done>
</task>

</tasks>

<verification>
1. `nuxt build` succeeds and produces `.output/server/` with function entry point
2. Server function bundle is within Lambda size limits
3. Build time is under 2 minutes (no 13K route prerendering)
4. Site is live on Netlify serving pages via SSR
5. `/api/health` returns `status: ok` with SQLite query results
6. Page TTFB is under 3 seconds (including cold start)
</verification>

<success_criteria>
The SSR deploy pipeline is proven end-to-end. Site is live on Netlify, health endpoint confirms SQLite works in the Lambda runtime, and cold start TTFB meets the 3-second threshold. Phase 5 success criteria from the roadmap are satisfied.
</success_criteria>

<output>
After completion, create `.planning/phases/05-ssr-deploy-pipeline/05-02-SUMMARY.md`
</output>
